Design Notes: Unix Shell
1. Problem Analysis
Week 1:
Our first iteration was a static shell. It could only perform tasks we specifically wrote code for (cd and pwd). If a user wanted to run ls or mkdir, the shell was useless because it didn't know how to talk to the Operating System's program library. To create a real shell, the program must be able to take any command name, find that program on the disk, and run it as a separate process while the shell waits for it to finish.

Week 2:
The challenge shifted from basic execution to managing data streams and process lifecycles. A robust shell must be able to redirect standard input and output to files, allowing programs to communicate via the filesystem. Additionally, users need the ability to run long-running tasks in the "background," which requires the shell to manage multiple concurrent processes without blocking the primary command loop.

Week 3:
As the complexity of background tasks grew, the problem became one of state management. We needed a way to track which processes were still running and which had finished, ensuring the shell could clean up resources (preventing zombie processes) while keeping the user informed of job statuses.

Week 4:
The final challenge was ensuring system stability and memory safety. With multiple modules and dynamic memory allocations for command arguments, it was necessary to implement a strict testing and cleanup strategy to prevent memory leaks and file descriptor exhaustion.

2. Solution Architecture
Week 1:
Uses strtok to split the user's input string into an array of strings (args[]). This allows for flags like -l or -a to be passed correctly. Before trying to run a program, the shell checks if the command is built-in (like cd or exit). These must run in the parent process because they modify the shell's own state.
For all other commands, the shell uses the Fork-Exec-Wait pattern: 
1. Create a child process. 
2. Replace the child process with the desired program (e.g., ls).
3. The parent shell pauses until the child process is done.

Week 2-3:
The architecture evolved into a modular system that decouples parsing from execution using a centralized Command structure.

I/O Redirection: The execution engine uses dup2() to clone file descriptors for files opened via open(). This ensures that execvp() targets the correct input or output stream based on the user's redirection symbols (<, >, >>).

Background Management: A dedicated jobs.c module was implemented to maintain a stateful array of active PIDs and command strings. This uses waitpid() with the WNOHANG flag during every iteration of the Read-Eval-Print Loop (REPL) to reap child processes non-blockingly.

Week 4:
Memory Safety and Stability: To achieve high reliability, the shell implements strict memory and resource management.

Fixing Memory Leaks and Dangling Pointers: We resolved memory safety issues by ensuring every token generated by strtok is duplicated via strdup to allocate dedicated memory for each argument. This prevents dangling pointers when the original input buffer is modified. All such allocations are subsequently deallocated using a centralized free_command function after every execution cycle.

Resource Cleanup: To prevent file descriptor leaks, dup2 is immediately followed by close() for any file opened during I/O redirection, guaranteeing the child process executes in a clean environment.

3. Laboratory Implementation Timeline
Week 1:
Goal: Interactive Command Loop, Built-in Commands, External Command Execution
Week 2: 
Goal: I/O Redirection, Background Execution, Required System Calls
Week 3:
Goal: Data Structures, Process Execution, File Descriptor Management and Background Process Management
Week 4: 
Goal: Testing Strategy